/**************************************************************
 *                                                            *
 *                            NEXUS                           *
 *                                                            *
 *              (c) 1990 Paul Sajda and Leif Finkel           *
 *                                                            *
 *                           (io.c)                           *
 *                                                            *
 *  nexus_build.c, nexus_load.c, nexus_save.c:                *
 *          modified 10/30/91 by K.Sakai, 12/27/91            *
 **************************************************************/

#include "nexus.h"
#include "memory.h"
#include "input_output.h"
#include "graphics.h"

#ifdef NEXUS_RBF
#include	"rbf.h"
#endif



/***************************************************************************
 **  nexus_build.c
 ***************************************************************************/

/**
 **  Global variables; used also in nexus_lex_build.l.
 **/

WEIGHT_ARRAY 	weights_from_files;
NEXUS		nexus_head;


/***********
 *  nexus_build.c:
 *    Call yylex( ) function which was generated by lex.
 ***********/

int
read_network( fp )
    FILE *fp;
{ 
  extern NEXUS		nexus_head;
  extern WEIGHT_ARRAY 	weights_from_files;
  extern FILE		*fpin, *fpout;  	/* local to nex_lex_build.l */
  extern int		net_check[][10];	/* syntax check from yylex() */
  
  NETWORK	network;
  
  char		*dev_null="/dev/null";
  int           i, j;
  int		yylex( );
  
  
  /* fprintf ( stderr, " Building networks. \n" ); */
  fprintf( stderr, "\n" );
  
  nexus_head = (NEXUS) nxMalloc( SIZE_NEXUS );
  network_head = (NETWORK) nxMalloc( SIZE_NETWORK );

  /* 01/18/93: */
  weights_from_files = (WEIGHT_ARRAY) nxMalloc( SIZE_WEIGHT_ARRAY );
  
  if ((fpout = fopen(dev_null, "w")) == NULL) {
    fprintf( stderr, "Can't open file '%s'. \n", dev_null );
    fprintf( stderr, "ABORTing.\n" );
    exit( ERROR );
  }
  
  fpin = fp;

  /*****************************************************
   *  yylex() function is in nexus_lex_build.c, which
   *    is generated by lex from nexus_lex_build.l.
   *****************************************************/

  if (yylex( ) == ERROR) {
    fprintf( stderr," ERROR in building networks.    - yylex() \n");
    fclose( fpin );
    fclose( fpout );
    return FALSE;
  }
  
  fclose (fpin);
  fclose (fpout);
  
  freeLearningMethods( );

  /* check existance of statements , if not exist, set default	*/
  network = network_head;
  for (j = 1; j <= number_networks; j++) {
    for (i = 1; i <= 9; i++) {		/*  0 for network definition 	*/
      /* fprintf (stderr,"net: %d %d %d\n",j,i,net_check[j][i]); 	*/ 
      if (net_check[j][i] == OFF) {
	if ((network->extern_connections)->extern_from == OFF) {
	  fprintf( stderr,
		  " WARNING in NX file: undefined network parameter(s)" );
	  fprintf( stderr, "in network #%d, parameter #%d\n",j,i );
	  switch (i) {
	  case 4:	
	    sprintf( network->class ,"binary" );
	    fprintf( stderr,
		    "               -----  default value (binary) is set. \n");
	    break;
	  case 6:
	    network->decay = 1.0;
	    fprintf( stderr,
		    "               -----  default value (1.0) is set. \n");
	    break;
	  case 9:
	    network->evaluations_per_cycle = 1;
	    fprintf( stderr,
		    "               -----  default value (1) is set. \n");
	    break;
	  }
	}
	if ( (network->extern_connections)->extern_from == ON ) {
	  if ( (i==1) || (i==2) || (i==3) ) {
	    fprintf( stderr,
		    " ERROR in NX file: undefined network parameter(s)\n");
	    fprintf( stderr,
		    "        	   in network #%d, parameter #%d\n",j,i );
	  }
	  if ( (i==8) || (i==9) ) {
	    fprintf( stderr,
		    " WARNING in NX file: undefined network parameter(s)\n");
	    fprintf( stderr,
		    "        	      in network #%d, parameter #%d\n",j,i );
	  }
	  /* set necessary variables */
	  sprintf( network->class ,"binary" );
	  network->decay = 1.0;
	}
      }
      net_check[j][i] = OFF;		/* reset for next building */
    }
    network = network->next;
  }

  make_xref_list( );
  update_network_lists( );

  resetView( );		/* DW 95.03.15 */

  /* fprintf (stderr," End building networks. \n"); */
  return TRUE;
}  /* read_network() */



float
get_threshold(func)
    char           *func;
{
  float           get_random _ANSI_ARGS_(( float, float ));
  float           max, min;
  float           constant;
  char            function[FUNCTION_SIZE], func_name[10];
  
  strcpy(function, func);
  sscanf(function, "%[^_] %*c", func_name);
  
  if (strcmp(func_name, "rand") == 0) {
    sscanf(function, "%*[^_] %*c %*[^_] %*c %f %*c %*[^_] %*c %f", &max, &min);
    return (get_random(min, max));
  }
  if (strcmp(func_name, "const") == 0) {
    sscanf(function, "%*[^_] %*c %f", &constant);
    return ((float) constant);
  } else {
    printf("ERROR - unknown threshold function '%s'\n", func_name);
    printf("Using a constant '1.0' as threshold\n");
    return (1.0);
  } 
}



/* get external nexus's file_write_dir	*/
/* nx file must include "self" nexus	*/

char *get_extern_dir(nex_name, nexuses_head)
    char           *nex_name;
    NEXUS           nexuses_head;
    
{
  NEXUS           nexuses;
  
  nexuses = nexuses_head;
  while (strcmp(nex_name, nexuses->name) != 0) {
    if ( nexuses->next == NULL ) return("");
    nexuses = nexuses->next;
  }
  
  /* now, nexuses is a head of "nex_name" nexus	 */
  return (nexuses->file_write_dir);
}








/***************************************************************************
 **  nexus_load.c
 ***************************************************************************/

void
load_simulation( file )
    char           *file;
{
  FILE		*fp;
  NETWORK	temp_network_head; /* DW 94.07.21 */
  NETWORK	temp_net, old_temp_net, search_net;
  CELL		temp_cell;
  SPECS		temp_specs, old_temp_specs;
  CONNECTION	temp_connection;
  char		check;
  int		count_cells, count_connections, id, net_id;
  char		*address, command[COMMAND_SIZE];


  number_networks = 0;
  printf("Loading Simulation - this may take a while . . .\n");

  /* check to see if file is compressed */
  if (query_flag( FILE_COMPRESSED )) {
    /* decompress save file for loading -- 7/5/94 J.B. */
    sprintf( command, "compress -fd %s\n", file );
    system( command );
    printf( "File decompressed\n" );
    address = strrchr( file, '.' );
    *address = '\0';   /* remove .Z suffix */       
  }

  fp = fopen( file, "r" );
  temp_net = (NETWORK) nxMalloc( SIZE_NETWORK );
  temp_net->extern_connections =
    (EXTERN_CONNECTION) nxMalloc( SIZE_EXTERN_CONNECTION );
  temp_network_head = temp_net;

  /*
   *  Network parsing loop.
   */

  while (fscanf( fp, "%c", &check ) != EOF) {
    if (check != 'N')
      break;			/* Break out of Network parsing loop. */
				/* Move on to Cell parsing loop. */

    number_networks++;

    fscanf(fp, "%*c%d %s  %f %f %f %f %f %f %s %d %d %d %d %f %f %f %f %f",
	   &(temp_net->id),
	   temp_net->name,
	   &(temp_net->pos_x),
	   &(temp_net->pos_y),
	   &(temp_net->cell_size),
	   &(temp_net->name_size_w),
	   &(temp_net->name_size_h),
	   &(temp_net->decay),
	   (temp_net->class),
	   &(temp_net->number_cells),
	   &(temp_net->dim_x),
	   &(temp_net->dim_y),
	   &(temp_net->evaluations_per_cycle),
	   &(temp_net->function_slope),
	   &(temp_net->function_min),
	   &(temp_net->function_max),
	   &(temp_net->scale),
	   &(temp_net->offset));

    /* extern connections */
    fscanf(fp, "%d %d ",
	   &((temp_net->extern_connections)->extern_to), 
	   &((temp_net->extern_connections)->extern_from) );
    if ( (temp_net->extern_connections)->extern_to == TRUE )
      fscanf(fp, "%d %s ",
	     &((temp_net->extern_connections)->extern_to_times),
	     (temp_net->extern_connections)->extern_to_dir );
    if ( (temp_net->extern_connections)->extern_from == TRUE )
      fscanf(fp, "%d %s %s %s %s ",
	     &((temp_net->extern_connections)->extern_from_times),
	     (temp_net->extern_connections)->extern_from_dir,
	     (temp_net->extern_connections)->extern_from_net,
	     (temp_net->extern_connections)->extern_from_nex,
	     (temp_net->extern_connections)->extern_from_opt );

    temp_net->cells = (CELL) nxCalloc( temp_net->number_cells, SIZE_CELL );
    temp_net->next = (NETWORK) nxMalloc( SIZE_NETWORK );
    old_temp_net = temp_net;
    temp_net = temp_net->next;
    temp_net->extern_connections =
      (EXTERN_CONNECTION) nxMalloc( SIZE_EXTERN_CONNECTION );
  }

  /*
   * Fixed core leak, added free() statements.
   * DW 94.07.13
   */
  free( temp_net->extern_connections );
  free( temp_net );
  old_temp_net->next = NULL;

  temp_net = temp_network_head;

  /*
   *  Cell parsing loop.
   */

  while (temp_net != NULL) {

    for (count_cells = 0;
	 count_cells < temp_net->number_cells;
	 count_cells++) {

      temp_cell = temp_net->cells + count_cells;
      fscanf(fp, "%*[^_]");
      fscanf(fp, "%*c%d %d %f %f %f %f %d %d %d %d\n",
	     &(temp_cell->id),
	     &(temp_cell->net_id),
	     &(temp_cell->voltage),
	     &(temp_cell->firing_rate),
	     &(temp_cell->firing_rate_old),
	     &(temp_cell->threshold),
	     &(temp_cell->clamp),
	     &(temp_cell->net_connections),
	     &(temp_cell->number_connections),
	     &(temp_cell->number_outputs));
      fscanf(fp, "\t%c", &check);
      if (check != 'S')
	temp_cell->specs = NULL;
      else {
	temp_cell->specs = (SPECS) nxMalloc( SIZE_SPECS );
	temp_specs = temp_cell->specs;
	while (TRUE) {
	  fscanf(fp, "%*c%d %d %d %d %d %d %d %d %d %d %d %d %d\n",
		 &(temp_specs->type),
		 &(temp_specs->mask_type),
		 &(temp_specs->connect_id),
		 &(temp_specs->id),
		 &(temp_specs->max_width),
		 &(temp_specs->max_height),
		 &(temp_specs->center_x),
		 &(temp_specs->center_y),
		 &(temp_specs->major_dim),
		 &(temp_specs->minor_dim),
		 &(temp_specs->angle),
		 &(temp_specs->feedback),
		 &(temp_specs->plasticity));
	  temp_specs->next = (SPECS) nxMalloc( SIZE_SPECS );
	  old_temp_specs = temp_specs;
	  temp_specs = temp_specs->next;

	  /*
	   *  Bug fix found by polk@cattell.psych.upenn.edu:
	   *    "If a line of specifications is the last line of the file
	   *     then the indicated fscanf will hit an EOF and the value of
	   *     check will not change.  Thus the while loop will never break."
	   *  Original:
	   *      fscanf(fp, "\t%c", &check);
	   *      if (check != 'S') break;
	   *  DW 94.07.19
	   */

/*	  printf( " next character: '%c'\n", (check = getc( fp )) ); */
/*	  ungetc( check, fp ); */
	  if( (fscanf(fp, "\t%c", &check) == EOF)
	     || (check != 'S') )
	    break;

	}  /* while (TRUE) */

	old_temp_specs->next = NULL;
      }  /* else there are more SPECifications */


      /*
       *  Bug Fix: If there are no connections, do not bother with this part.
       *    DW 94.11.14
       */

      if (temp_cell->number_connections) {

	temp_cell->connect_list =
	  (CONNECTION) nxCalloc( temp_cell->number_connections,
				SIZE_CONNECTION );

	for (count_connections = 0;
	     count_connections < temp_cell->number_connections;
	     count_connections++) {
	  temp_connection = temp_cell->connect_list + count_connections;
	  fscanf(fp, "%*[^_]");
	  fscanf(fp, "%*c%d %d %f\n",
		 &id,
		 &net_id,
		 &(temp_connection->conductance));

	  search_net = temp_network_head;
	  while (search_net->id != net_id)
	    search_net = search_net->next;
	  temp_connection->input_cell = search_net->cells + (id - 1);
	}

      }  /* if (temp_cell->number_connections) */
      else
	temp_cell->connect_list = NULL;



      /*
       *  Bug Fix: If there are no pgn connex, do not bother with this part.
       *    DW 94.11.14
       */

      if (temp_cell->number_outputs) {

	temp_cell->output_list =
	  (CONNECTION) nxCalloc( temp_cell->number_outputs, SIZE_CONNECTION );

	for (count_connections = 0;
	     count_connections < temp_cell->number_outputs;
	     count_connections++) {
	  temp_connection = temp_cell->output_list + count_connections;
	  fscanf(fp, "%*[^_]");
	  fscanf(fp, "%*c%d %d %f\n",
		 &id,
		 &net_id,
		 &(temp_connection->conductance));

	  search_net = temp_network_head;
	  while (search_net->id != net_id)
	    search_net = search_net->next;
	  temp_connection->input_cell = search_net->cells + (id - 1);
	}

      }  /* if (temp_cell->number_outputs) */
      else
	temp_cell->output_list = NULL;

    }

    printf( "Finished loading network '%s'.\n", temp_net->name );
    temp_net = temp_net->next;
  }

  network_head = temp_network_head;

  make_xref_list( );
  update_network_lists( );

  freeLearningMethods( );



#ifdef NEXUS_RBF
  check = (char) fgetc( fp );
  if (check == 'R') {
    ungetc( (int) check, fp );
    load_rbf_networks( fp );
  }
  fclose(fp);
#endif /* NEXUS_RBF */


  resetView( );		/* DW 95.03.15 */


  /* recompress file if necessary -- 7/11/94 J.B. */
  if (query_flag( FILE_COMPRESSED )) {
    sprintf( command, "compress %s\n", file );
    system( command );
  }
}  /* load_simulation( ) */








/***************************************************************************
 **  nexus_save.c
 ***************************************************************************/

/*
 * Code to save the current state of the simulator.
 * Note that these saved files are rather large so one
 * should avoid saving large networks unless the archtecture
 * is reasonably certain.
 */

void
save_simulation( head, file )
    NETWORK         head;
    char           *file;
{
  NETWORK         temp_net;
  CELL            temp_cell;
  SPECS           temp_specs;
  CONNECTION      temp_connection;
  FILE           *fp;
  int             count_cells, count_connections;
  char            command[FUNCTION_ARG_SIZE];
  
#ifdef NEXUS_RBF
  extern void     save_rbf_networks();
#endif /* NEXUS_RBF */


  updateNetPositions( );

  printf("Saving Simulation - this may take a while . . .\n");
  temp_net = head;
  fp = fopen(file, "w");
  /* store all network info. */
  while (temp_net != NULL) {
    fprintf(fp, "N_%d %s %g %g %g %g %g %g %s %d %d %d %d %g %g %g %g %g",
	    temp_net->id,
	    temp_net->name,
	    temp_net->pos_x,
	    temp_net->pos_y,
	    temp_net->cell_size,
	    temp_net->name_size_w,
	    temp_net->name_size_h,
	    temp_net->decay,
	    temp_net->class,
	    temp_net->number_cells,
	    temp_net->dim_x,
	    temp_net->dim_y,
	    temp_net->evaluations_per_cycle,
	    temp_net->function_slope,		/* rev. 12/27/91 */
	    temp_net->function_min,
	    temp_net->function_max,
	    temp_net->scale,
	    temp_net->offset);
    
    /* extern connections */
    fprintf( fp, " %d %d",
	    (temp_net->extern_connections)->extern_to, 
	    (temp_net->extern_connections)->extern_from );
    if ((temp_net->extern_connections)->extern_to == TRUE)
      fprintf( fp, " %d %s",
	      (temp_net->extern_connections)->extern_to_times,
	      (temp_net->extern_connections)->extern_to_dir );
    if ((temp_net->extern_connections)->extern_from == TRUE)
      fprintf(fp, " %d %s %s %s %s",
	      (temp_net->extern_connections)->extern_from_times,
	      (temp_net->extern_connections)->extern_from_dir,
	      (temp_net->extern_connections)->extern_from_net,
	      (temp_net->extern_connections)->extern_from_nex,
	      (temp_net->extern_connections)->extern_from_opt );
    fprintf(fp, "\n");

    temp_net = temp_net->next;
  }

  /* store cell info. */
  temp_net = head;
  while (temp_net != NULL) {
    for (count_cells = 0;
	 count_cells < temp_net->number_cells;
	 count_cells++) {
      temp_cell = temp_net->cells + count_cells;
      fprintf(fp, "C_%d %d %g %g %g %g %d %d %d %d\n",
	      temp_cell->id,
	      temp_cell->net_id,
	      temp_cell->voltage,
	      temp_cell->firing_rate,
	      temp_cell->firing_rate_old,
	      temp_cell->threshold,
	      temp_cell->clamp,
	      temp_cell->net_connections,
	      temp_cell->number_connections,
	      temp_cell->number_outputs);
      temp_specs = temp_cell->specs;
      while (temp_specs != NULL) {
	fprintf(fp, "\tS_%d %d %d %d %d %d %d %d %d %d %d %d %d\n",
		temp_specs->type,
		temp_specs->mask_type,
		temp_specs->connect_id,
		temp_specs->id,
		temp_specs->max_width,
		temp_specs->max_height,
		temp_specs->center_x,
		temp_specs->center_y,
		temp_specs->major_dim,
		temp_specs->minor_dim,
		temp_specs->angle,
		temp_specs->feedback,
		temp_specs->plasticity);
	temp_specs = temp_specs->next;
      }
      for (count_connections = 0;
	   count_connections < temp_cell->number_connections;
	   count_connections++) {
	temp_connection = temp_cell->connect_list + count_connections;
	fprintf(fp, "\t\tC_%d %d %g\n",
		(temp_connection->input_cell)->id,
		(temp_connection->input_cell)->net_id,
		temp_connection->conductance);
      }
      for (count_connections = 0;
	   count_connections < temp_cell->number_outputs;
	   count_connections++) {
	temp_connection = temp_cell->output_list + count_connections;
	fprintf(fp, "\t\tC_%d %d %g\n",
		(temp_connection->input_cell)->id,
		(temp_connection->input_cell)->net_id,
		temp_connection->conductance);
      }
    }
    printf("Finished Saving Network %s\n", temp_net->name);
    temp_net = temp_net->next;
  }

#ifdef NEXUS_RBF
  save_rbf_networks(fp);
#endif /* NEXUS_RBF */


  fclose(fp);
  
  /* compress save file to save space -- 7/5/94 J.B. */
  if (query_flag( FILE_COMPRESSED )) {
    sprintf( command, "compress -f %s\n", file );
    system( command );
    printf("File compressed and saved.\n");
  } else
    printf("File saved.\n");
}  /* save_simulation( ) */










/* Emacs editing section. DW 94.07.19 */

/*
Local Variables:
c-indent-level:2
c-continued-statement-offset:2
c-brace-offset:0
c-brace-imaginary-offset:0
c-argdecl-indent:4
c-label-offset:-2
c-auto-newline:nil
truncate-partial-width-windows:nil
truncate-lines:nil
End:
*/
